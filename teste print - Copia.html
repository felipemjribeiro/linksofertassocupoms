<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Blocos com bot√£o Copiar</title>

  <!-- Fonte (fallback) -->
  <link href="https://fonts.googleapis.com/css2?family=Proxima+Nova:wght@400;600;700&display=swap" rel="stylesheet">

  <!-- html2canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
    :root{ --block-w: 540px; --block-h: 960px; }
    body{ font-family:"Proxima Nova", Arial, sans-serif; margin:20px; background:#f7f7f7; }
    .page{ max-width:1200px; margin:0 auto; }
    h2{ text-align:center; margin-bottom:10px; }
    .note{ text-align:center; color:#555; font-size:13px; margin-bottom:12px; }

    .block-wrapper{ display:flex; align-items:flex-start; gap:16px; margin:18px 0; }
    .controls{ display:flex; flex-direction:column; gap:8px; min-width:120px; }
    .controls .copy-btn, .controls .print-btn{ padding:8px 12px; border-radius:6px; border:none; cursor:pointer; font-weight:600; color:#fff; }
    .controls .copy-btn{ background:#0b74de; } .controls .copy-btn.copied{ background:#2ecc71; }
    .controls .print-btn{ background:#444; }

    .block{
      width:var(--block-w); height:var(--block-h);
      background:#fff; border-radius:8px; padding:30px; box-shadow:0 1px 6px rgba(0,0,0,0.08);
      position:relative; box-sizing:border-box; overflow:hidden; display:flex; flex-direction:column; gap:12px;
    }

    .image-container{ width:480px; height:540px; background:#fff; border-radius:6px; overflow:hidden; align-self:center; display:flex; justify-content:center; align-items:center; }
    .image-container img{ width:100%; height:100%; object-fit:contain; background:#fff; display:block; }

    .content{ white-space:normal; display:flex; flex-direction:column; gap:10px; font-family:"Proxima Nova",Arial,sans-serif; overflow:auto; }
    .item{ line-height:1.25; }
    .item.titulo{ font-size:22px; font-weight:600; }
    .item.vendidos{ font-size:14px; }
    .item.preco-de{ font-size:16px; text-decoration:line-through; opacity:0.8; }
    .item.preco-por{ font-size:36px; font-weight:bold; color:#111; }
    .item.desconto{ font-size:18px; color:#00A650; background:#00A6501A; padding:6px 10px; width:fit-content; border-radius:4px; }
    .item.cupom{ font-size:36px; font-weight:700; }
    .item.frete{ font-size:12px; background:#00A650; color:#fff; padding:4px 8px; border-radius:4px; width:fit-content; }
    .item.link{ font-size:18px; color:#0066CC; text-decoration:underline; word-break:break-all; }

    @media (max-width:720px){ .block-wrapper{ flex-direction:column; align-items:center; } .controls{ flex-direction:row; gap:8px; } .image-container{ width:320px; height:360px; } }

    ._print-clone{ box-sizing:border-box; padding:14px; background:#fff; color:#222; font-family:"Proxima Nova",Arial,sans-serif; font-size:14px; box-shadow:none !important; }
  </style>
</head>
<body>
  <div class="page" id="page-root">
    <h2>Lista de ofertas</h2>
    <div class="note">S√≥ Cupons</div>

    <div class="block-wrapper">
      <div class="controls">
        <button class="copy-btn" data-target="block-1">Copiar</button>
        <button class="print-btn" data-target="block-1">Print</button>
      </div>

      <div class="block" id="block-1">
        <div class="image-container">
          <img src="caneta.webp" alt="imagem do produto" />
        </div>

        <div class="content">
          <div class="item titulo">‚û°Ô∏è Kit 3 Squishy Brinquedo Apertar Taba Squishies Bichinho Moji</div>
          <div class="item vendidos">‚úÖ Mais de +1000 ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
          <div class="item preco-de">üìàDe R$ 39,90</div>
          <div class="item preco-por">üíµPor: R$ 24,9</div>
          <div class="item desconto">(50% OFF)</div>
          <div class="item cupom">üè∑ Cupom: XXXX</div>
          <div class="item frete">üöõ Frete Gr√°tis</div>
          <a class="item link" href="https://mercadolivre.com/sec/2ECowoD" target="_blank">üõí https://mercadolivre.com/sec/2ECowoD</a>
        </div>
      </div>
    </div>

    <!-- blocks 2 & 3 left unchanged for now -->
    <div class="block-wrapper">
      <div class="controls">
        <button class="copy-btn" data-target="block-2">Copiar</button>
        <button class="print-btn" data-target="block-2">Print</button>
      </div>
      <div class="block" id="block-2">
        <div class="image-container"><img src="caneta.webp" alt=""></div>
        <div class="content">‚û°Ô∏è Kit 2 Refil Filtro...</div>
      </div>
    </div>

    <div class="block-wrapper">
      <div class="controls">
        <button class="copy-btn" data-target="block-3">Copiar</button>
        <button class="print-btn" data-target="block-3">Print</button>
      </div>
      <div class="block" id="block-3">
        <div class="image-container"><img src="caneta.webp" alt=""></div>
        <div class="content">‚û°Ô∏è Tag De Localiza√ß√£o...</div>
      </div>
    </div>

  </div>

  <script>
  // --- util: convert image via Image.onload, fallback to fetch->blob->dataURL ---
  function toDataURLViaImage(src, targetW, targetH, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      // don't force crossOrigin to avoid some file:// errors
      img.onload = () => {
        try {
          const canvas = document.createElement('canvas');
          canvas.width = targetW; canvas.height = targetH;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
          const iw = img.naturalWidth, ih = img.naturalHeight;
          const scale = Math.min(targetW / iw, targetH / ih);
          const w = Math.round(iw * scale), h = Math.round(ih * scale);
          const dx = Math.round((targetW - w)/2), dy = Math.round((targetH - h)/2);
          ctx.drawImage(img, 0,0, iw, ih, dx, dy, w, h);
          resolve(canvas.toDataURL('image/png'));
        } catch (err) { reject(err); }
      };
      img.onerror = () => reject(new Error('image-load-failed'));
      img.src = src;
      // timeout fallback
      setTimeout(()=>{ if (!img.complete) reject(new Error('image-load-timeout')); }, timeout);
    });
  }

  function blobToDataURL(blob) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = (e) => reject(e);
      fr.readAsDataURL(blob);
    });
  }

  async function toDataURLViaFetch(src, targetW, targetH) {
    // try fetch -> blob -> draw onto canvas (to preserve contain)
    try {
      const res = await fetch(src, {mode: 'cors'}); // may fail for file:// depending on browser
      if (!res.ok) throw new Error('fetch-failed: ' + res.status);
      const blob = await res.blob();
      // create img from blob first to get naturalWidth/naturalHeight reliably
      const dataUrlFromBlob = await blobToDataURL(blob);
      // draw with Image path using dataURL (should always work)
      return await toDataURLViaImage(dataUrlFromBlob, targetW, targetH);
    } catch (err) {
      throw err;
    }
  }

  // high-level attempt sequence for a given <img> element
  async function convertImgElement(imgEl) {
    const origSrc = imgEl.getAttribute('src') || '';
    if (!origSrc) return null;
    if (origSrc.startsWith('data:')) return null; // already ok

    const parentIsContainer = imgEl.closest('.image-container') !== null;
    const tW = parentIsContainer ? 480 : Math.round(imgEl.width) || 480;
    const tH = parentIsContainer ? 540 : Math.round(imgEl.height) || 540;

    const resolved = imgEl.src; // absolute URL if possible
    console.log('convertImgElement: trying', resolved);

    // try 1: Image onload
    try {
      const dataUrl = await toDataURLViaImage(resolved, tW, tH, 6000);
      console.log('converted via image.onload:', resolved);
      return dataUrl;
    } catch (err1) {
      console.warn('toDataURLViaImage failed', err1);
    }

    // try 2: fetch -> blob -> dataURL -> draw
    try {
      const dataUrl = await toDataURLViaFetch(resolved, tW, tH);
      console.log('converted via fetch:', resolved);
      return dataUrl;
    } catch (err2) {
      console.warn('toDataURLViaFetch failed', err2);
    }

    // try 3: last-resort ‚Äî draw the rendered DOM image onto canvas by creating an offscreen clone and using drawImage with the DOM img (may still fail)
    try {
      const canvas = document.createElement('canvas');
      canvas.width = tW; canvas.height = tH;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,tW,tH);
      // attempt to draw the DOM img element directly (if image already decoded and accessible)
      ctx.drawImage(imgEl, 0,0, imgEl.naturalWidth || tW, imgEl.naturalHeight || tH, 0,0, tW, tH);
      const d = canvas.toDataURL('image/png');
      console.log('converted via direct draw fallback', resolved);
      return d;
    } catch (err3) {
      console.warn('direct draw fallback failed', err3);
    }

    // If everything fails, return null (caller will handle)
    console.error('All conversion strategies failed for', resolved);
    return null;
  }

  // convert all images in block (mutates src -> dataURL), returns originals array for restore
  async function convertBlockImages(block) {
    const imgs = Array.from(block.querySelectorAll('img'));
    const originals = [];
    for (const img of imgs) {
      originals.push({el: img, src: img.getAttribute('src') || ''});
      try {
        const dataURL = await convertImgElement(img);
        if (dataURL) {
          img.setAttribute('src', dataURL);
          img.style.width = (img.closest('.image-container') ? 480 : img.width || 480) + 'px';
          img.style.height = (img.closest('.image-container') ? 540 : img.height || 540) + 'px';
          img.style.objectFit = 'contain';
          img.style.display = 'block';
        } else {
          console.warn('convertBlockImages: could not convert', img);
        }
      } catch (err) {
        console.warn('convertBlockImages error for', img, err);
      }
    }
    return originals;
  }

  function restoreOriginalImages(originals) {
    for (const o of originals) {
      try {
        o.el.setAttribute('src', o.src);
        o.el.style.width = '';
        o.el.style.height = '';
        o.el.style.objectFit = '';
        o.el.style.display = '';
      } catch (e) {}
    }
  }

  // hide/restore helpers
  function hidePageExcept(el) {
    const children = Array.from(document.body.children);
    const hidden = [];
    for (const c of children) {
      if (c === el) continue;
      const prev = c.getAttribute('data-prev-style') || c.getAttribute('style') || '';
      c.setAttribute('data-prev-style', prev);
      c.style.visibility = 'hidden';
      hidden.push(c);
    }
    return hidden;
  }
  function restoreHidden(hidden) {
    for (const c of hidden) {
      const prev = c.getAttribute('data-prev-style') || '';
      c.setAttribute('style', prev);
      c.style.visibility = '';
      c.removeAttribute('data-prev-style');
    }
  }

  // Copy handler
  document.addEventListener('click', async (e) => {
    const btn = e.target.closest('.copy-btn');
    if (!btn) return;
    const id = btn.getAttribute('data-target');
    const block = document.getElementById(id);
    if (!block) return;
    try {
      await navigator.clipboard.writeText(block.innerText);
      btn.classList.add('copied'); const old = btn.innerText; btn.innerText = 'Copiado!';
      setTimeout(()=>{ btn.classList.remove('copied'); btn.innerText = old; }, 1200);
    } catch (err) {
      alert('Erro ao copiar: ' + err);
    }
  });

  // Print handler (robust)
  document.addEventListener('click', async (e) => {
    const btn = e.target.closest('.print-btn');
    if (!btn) return;
    const id = btn.getAttribute('data-target');
    const block = document.getElementById(id);
    if (!block) return;

    const requiredW = 540, requiredH = 960;
    let originals = [];

    try {
      // 1) Convert images in the original block to data URLs (try multiple strategies)
      originals = await convertBlockImages(block);

      // 2) Create a visible clone at top-left, hide rest of page for rendering
      const clone = document.createElement('div');
      clone.className = '_print-clone';
      clone.style.width = requiredW + 'px'; clone.style.height = requiredH + 'px';
      clone.style.position = 'fixed'; clone.style.left = '0px'; clone.style.top = '0px';
      clone.style.zIndex = '999999'; clone.style.opacity = '1'; clone.style.overflow = 'hidden';
      clone.innerHTML = block.innerHTML;
      document.body.appendChild(clone);
      const hidden = hidePageExcept(clone);

      // 3) Wait a bit for layout and images
      await new Promise(r => setTimeout(r, 200)); // give more time

      // 4) Capture with html2canvas (foreignObjectRendering helps)
      const canvas = await html2canvas(clone, {
        width: requiredW, height: requiredH, scale: (window.devicePixelRatio || 1), useCORS: true,
        backgroundColor: '#ffffff', foreignObjectRendering: true
      });

      // 5) Ensure final canvas exact size and white background
      let finalCanvas = canvas;
      if (canvas.width !== requiredW || canvas.height !== requiredH) {
        const tmp = document.createElement('canvas');
        tmp.width = requiredW; tmp.height = requiredH;
        const ctx = tmp.getContext('2d');
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,tmp.width,tmp.height);
        ctx.drawImage(canvas, 0, 0, tmp.width, tmp.height);
        finalCanvas = tmp;
      } else {
        const tmp = document.createElement('canvas');
        tmp.width = requiredW; tmp.height = requiredH;
        const tctx = tmp.getContext('2d');
        tctx.fillStyle = '#ffffff'; tctx.fillRect(0,0,tmp.width,tmp.height);
        tctx.drawImage(finalCanvas, 0, 0);
        finalCanvas = tmp;
      }

      // 6) Download
      const link = document.createElement('a');
      link.download = `print-${id}.png`;
      link.href = finalCanvas.toDataURL('image/png');
      link.click();

      // 7) cleanup
      restoreHidden(hidden);
      clone.remove();
      restoreOriginalImages(originals);

    } catch (err) {
      console.error('PRINT ERROR:', err);
      alert('Erro ao gerar print: ' + (err && err.message ? err.message : err));
      // best-effort cleanup
      try { restoreOriginalImages(originals); } catch(e){}
    }
  });
  </script>
</body>
</html>
